================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-11-02T01:28:10.093Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitignore
config/database.js
Dockerfile
index.js
models/projection.model.js
package.json
public/index.html
scrapeLogic.js
whatsappLogic.js

================================================================
Repository Files
================================================================

================
File: .gitignore
================
/node_modules
.env
repopack-output

================
File: config/database.js
================
const mongoose = require('mongoose');

// Mostrar el URI en los logs
console.log('URI de conexión:', process.env.MONGO_DB_URI);

const conectarDB = async () => {
    try {
        if (!process.env.MONGO_DB_URI) {
            throw new Error('La variable de entorno MONGO_DB_URI no está definida');
        }

        // Conectar a MongoDB con una configuración mínima
        await mongoose.connect(process.env.MONGO_DB_URI, {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        });

        console.log('Conexión exitosa a MongoDB');
    } catch (error) {
        console.error('=== Error de Conexión ===');
        console.error('Tipo:', error.name);
        console.error('Mensaje:', error.message);
        process.exit(1);
    }
};

module.exports = conectarDB;

================
File: Dockerfile
================
FROM ghcr.io/puppeteer/puppeteer:19.7.2

ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true \
    PUPPETEER_EXECUTABLE_PATH=/usr/bin/google-chrome-stable

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm ci
COPY . .
CMD [ "node", "index.js" ]

================
File: index.js
================
const express = require("express");
const { createServer } = require("http");
const { Server } = require("socket.io");
const { scrapeLogic } = require("./scrapeLogic");
const conectarDB = require("./config/database");
const { initializeWhatsApp } = require("./whatsappLogic");
const path = require("path");

const app = express();
const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: {
    origin: process.env.NODE_ENV === "production" 
      ? ["https://testpuppeteer-1d96.onrender.com/"] 
      : ["http://localhost:4000"],
    methods: ["GET", "POST"]
  }
});

const PORT = process.env.PORT || 4000;

app.use(express.static(path.join(__dirname, 'public')));

app.get("/scrape", (req, res) => {
  scrapeLogic(res);
});

app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

io.on('connection', (socket) => {
  console.log('Cliente conectado:', socket.id);

  socket.on('disconnect', () => {
    console.log('Cliente desconectado:', socket.id);
  });
});

const iniciar = async () => {
  try {
    await conectarDB();
    console.log('Base de datos conectada');
    
    initializeWhatsApp(io);

    httpServer.listen(PORT, () => {
      console.log(`Servidor funcionando en puerto ${PORT}`);
    });
  } catch (error) {
    console.error('Error al iniciar el servidor:', error);
    process.exit(1);
  }
};


iniciar()

================
File: models/projection.model.js
================
const mongoose = require('mongoose');

const ProjectionSchema = new mongoose.Schema({
  nombrePelicula: {
    type: String,
    required: true,
  },
  fechaHora: {
    type: Date,
    required: true,
  },
  director: {
    type: String,
    default: 'No especificado',
  },
  genero: {
    type: String,
    default: 'No especificado',
  },
  duracion: {
    type: Number,
    default: 0,
  },
  sala: {
    type: String,
    default: '',
  },
  precio: {
    type: Number,
    default: 0,
  },
  habilitado: {
    type: Boolean,
    default: true,
  },
  fechaCreacion: {
    type: Date,
    default: Date.now,
  },
  cargaManual: {
    type: Boolean,
    default: false,
  },
  sitio: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Sites',
    required: true,
  },
  nombreCine: {
    type: String,
    required: true,
  },
  claveUnica: {
    type: String,
    unique: true,
    required: true,
  }
});

ProjectionSchema.index({ nombrePelicula: 1, fechaHora: 1, sitio: 1 }, { unique: true });

ProjectionSchema.methods.generarClaveUnica = function() {
  return `${this.nombrePelicula}-${this.fechaHora.toISOString()}-${this.sitio}`;
};

ProjectionSchema.pre('save', async function(next) {
  if (!this.claveUnica) {
    this.claveUnica = this.generarClaveUnica();
  }
  if (!this.nombreCine && this.sitio) {
    const site = await mongoose.model('Sites').findById(this.sitio);
    if (site) {
      this.nombreCine = site.nombre;
    }
  }
  next();
});

module.exports = mongoose.model('Projection', ProjectionSchema);

================
File: package.json
================
{
  "name": "puppeteer-render",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "mongoose": "^8.8.0",
    "openai": "^4.70.2",
    "puppeteer": "^19.7.2",
    "qrcode": "^1.5.4",
    "socket.io": "^4.8.0",
    "whatsapp-web.js": "^1.26.0"
  }
}

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhatsApp QR</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        .container {
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        #qrcode {
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #qrcode img {
            max-width: 100%;
            height: auto;
        }
        #status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .status-disconnected { background: #ff4444; color: white; }
        .status-loading { background: #ffbb33; color: black; }
        .status-authenticated { background: #00C851; color: white; }
        .status-ready { background: #33b5e5; color: white; }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WhatsApp Web Connector</h1>
        <div id="status">Conectando...</div>
        <div id="qrcode">
            <div class="loading"></div>
            <p>Esperando código QR...</p>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const qrcodeDiv = document.getElementById('qrcode');
        const statusDiv = document.getElementById('status');

        function updateStatus(data) {
            statusDiv.className = ''; // Limpiar clases anteriores
            statusDiv.classList.add(`status-${data.status}`);
            statusDiv.textContent = data.message;

            if (data.status === 'ready') {
                qrcodeDiv.style.display = 'none';
            } else if (data.status === 'disconnected') {
                qrcodeDiv.style.display = 'block';
            }
        }

        socket.on('connect', () => {
            console.log('Conectado a Socket.IO');
            socket.emit('requestQR');
        });

        socket.on('whatsappQR', (data) => {
            qrcodeDiv.innerHTML = `<img src="${data.qrCode}" alt="WhatsApp QR Code">`;
        });

        socket.on('whatsappStatus', (data) => {
            updateStatus(data);
        });

        socket.on('error', (data) => {
            console.error('Error:', data.message);
            statusDiv.className = 'status-disconnected';
            statusDiv.textContent = data.message;
        });

        socket.on('disconnect', () => {
            updateStatus({
                status: 'disconnected',
                message: 'Desconectado del servidor'
            });
        });
    </script>
</body>
</html>

================
File: scrapeLogic.js
================
const puppeteer = require("puppeteer");
require("dotenv").config();

const scrapeLogic = async (res) => {
  const browser = await puppeteer.launch({
    args: [
      "--disable-setuid-sandbox",
      "--no-sandbox",
      "--single-process",
      "--no-zygote",
    ],
    executablePath:
      process.env.NODE_ENV === "production"
        ? process.env.PUPPETEER_EXECUTABLE_PATH
        : puppeteer.executablePath(),
  });
  try {
    console.log("Iniciando scraping de books.toscrape.com...");
    const page = await browser.newPage();
    
    // Navegar a la página
    await page.goto("https://books.toscrape.com/", {
      waitUntil: 'networkidle0',
      timeout: 30000
    });

    console.log("Página cargada, buscando el mensaje...");
    
    // Obtener el texto dentro de <small>
    const welcomeMessage = await page.evaluate(() => {
      const smallElement = document.querySelector('small');
      return smallElement ? smallElement.textContent : null;
    });

    if (welcomeMessage) {
      console.log("Mensaje encontrado:", welcomeMessage);
      res.send(`Mensaje extraído: ${welcomeMessage}`);
    } else {
      throw new Error("No se pudo encontrar el elemento <small>");
    }

  } catch (e) {
    console.error("Error durante el scraping:", e);
    res.send(`Ocurrió un error: ${e.message}`);
  } finally {
    await browser.close();
  }
};

module.exports = { scrapeLogic };

================
File: whatsappLogic.js
================
const { Client } = require('whatsapp-web.js');
const qrcode = require('qrcode');
const puppeteer = require("puppeteer");
const { OpenAI } = require('openai');
const Projection = require('./models/projection.model');
require('dotenv').config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function processMessage(msg) {
  try {
    const proyecciones = await Projection.find({ habilitado: true })
      .sort({ fechaHora: 1 })
      .limit(5);

    const contextoPeliculas = proyecciones.map(p => ({
      pelicula: p.nombrePelicula,
      cine: p.nombreCine,
      horario: new Date(p.fechaHora).toLocaleString(),
      genero: p.genero,
      director: p.director,
      precio: p.precio
    }));

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: `Eres un asistente amigable de cine que ayuda a los usuarios que quieren saber que pelis hay para ver. 
                   Respondes de manera natural y concisa, usando emojis ocasionalmente. 
                   Si preguntan por la cartelera o películas disponibles, usa esta información: ${JSON.stringify(contextoPeliculas)}.
                   Puedes asistir con recomendaciones, dando mas informacion de la pelicula, etc. pero no puedes desviarte del tema del cine o la cartelera.
                   Declina amablemente y redirige la conversacion a la cartelera si esto pasa.`
        },
        { role: "user", content: msg.body }
      ],
      max_tokens: 150,
      temperature: 0.7
    });

    await msg.reply(response.choices[0].message.content);
  } catch (error) {
    console.error('Error al procesar mensaje:', error);
    await msg.reply('Disculpa, tuve un problema al procesar tu mensaje. ¿Podrías intentarlo de nuevo?');
  }
}



const initializeWhatsApp = async (io) => {
  let qrCode = null;
  let clientStatus = 'disconnected';

  const client = new Client({
    puppeteer: {
      args: [
        "--disable-setuid-sandbox",
        "--no-sandbox",
        "--single-process",
        "--no-zygote",
      ],
      executablePath: process.env.NODE_ENV === "production"
        ? process.env.PUPPETEER_EXECUTABLE_PATH
        : puppeteer.executablePath(),
    }
  });

  client.on('qr', async (qr) => {
    try {
      qrCode = await qrcode.toDataURL(qr);
      io.emit('whatsappQR', { qrCode });
      console.log('Nuevo código QR generado');
    } catch (error) {
      console.error('Error al generar QR:', error);
      io.emit('error', { message: 'Error al generar código QR' });
    }
  });

  client.on('loading_screen', (percent, message) => {
    console.log('CARGANDO ->', percent, message);
    io.emit('whatsappStatus', { status: 'loading', percent, message });
  });

  client.on('authenticated', () => {
    clientStatus = 'authenticated';
    io.emit('whatsappStatus', { 
      status: clientStatus,
      message: '¡WhatsApp autenticado exitosamente!' 
    });
    console.log('AUTENTICADO');
  });

  client.on('auth_failure', (msg) => {
    clientStatus = 'auth_failure';
    io.emit('whatsappStatus', { 
      status: clientStatus,
      message: 'Falló la autenticación de WhatsApp' 
    });
    console.error('ERROR DE AUTENTICACIÓN:', msg);
  });

  client.on('ready', () => {
    clientStatus = 'ready';
    io.emit('whatsappStatus', { 
      status: clientStatus,
      message: '¡WhatsApp está listo!' 
    });
    console.log('CLIENTE LISTO');
  });

  client.on('disconnected', (reason) => {
    clientStatus = 'disconnected';
    io.emit('whatsappStatus', { 
      status: clientStatus,
      message: `WhatsApp desconectado: ${reason}` 
    });
    console.log('CLIENTE DESCONECTADO:', reason);
  });

  client.on('message', async (msg) => {
    console.log('MENSAJE RECIBIDO:', msg.body);
    await processMessage(msg);
  });

  io.on('connection', (socket) => {
    console.log('Nuevo cliente Socket.IO conectado');
    
    if (qrCode) {
      socket.emit('whatsappQR', { qrCode });
    }
    
    socket.emit('whatsappStatus', { 
      status: clientStatus,
      message: `Estado actual: ${clientStatus}` 
    });

    socket.on('requestQR', () => {
      if (qrCode) {
        socket.emit('whatsappQR', { qrCode });
      }
    });
  });

  try {
    await client.initialize();
  } catch (error) {
    console.error('Error al inicializar WhatsApp:', error);
    io.emit('error', { 
      message: 'Error al inicializar WhatsApp',
      error: error.message 
    });
  }
};

module.exports = { initializeWhatsApp };
